Datei: app.py
Pfad: ..\app.py
Inhalt:
from flask import Flask, jsonify
from flask_restful import Api
from flask_cors import CORS
from flask_jwt_extended import JWTManager
from config import Config
from utils.logging_config import configure_logging
from resources.auth import Register, Login
from resources.questions import QuestionsList
from resources.lexicon import LexiconList
import logging

# Flask-App-Instanz erstellen
app = Flask(__name__)
app.config.from_object(Config)

# JWT initialisieren
jwt = JWTManager(app)

# Cross-Origin Resource Sharing
CORS(app)

# Flask-RESTful API
api = Api(app)

# Logging konfigurieren
configure_logging(app.config['DEBUG'])

# Fehlerbehandlung registrieren
@app.errorhandler(Exception)
def handle_exception(e):
    logging.error(f"Unhandled Exception: {e}")
    return jsonify({'message': 'An internal server error occurred'}), 500

# API-Ressourcen hinzufügen
api.add_resource(Register, '/api/register')
api.add_resource(Login, '/api/login')
api.add_resource(QuestionsList, '/api/questions')
api.add_resource(LexiconList, '/api/lexicon')

# Main-Block
if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000, debug=True)

=======

Datei: config.py
Pfad: ..\config.py
Inhalt:
from dotenv import load_dotenv
import os

load_dotenv()  # Lädt die .env-Datei

class Config:
    DEBUG = os.getenv('DEBUG', 'True') == 'True'
    TESTING = os.getenv('TESTING', 'False') == 'True'
    MONGODB_URI = os.getenv('MONGODB_URI', 'mongodb://192.168.178.25:49160/')
    DATABASE_NAME = os.getenv('DATABASE_NAME', 'exam_app')
    SECRET_KEY = os.getenv('SECRET_KEY', 'your_secret_key')
    JWT_SECRET_KEY = os.getenv('JWT_SECRET_KEY', 'your_jwt_secret_key')

=======

Datei: test_startup.py
Pfad: ..\test_startup.py
Inhalt:
import requests
from utils.database import client
from config import Config
import logging
import sys
import locale

# Setze Standard-Encoding auf UTF-8
sys.stdout.reconfigure(encoding='utf-8')
sys.stderr.reconfigure(encoding='utf-8')

logging.basicConfig(level=logging.INFO, format="%(asctime)s [%(levelname)s] %(message)s")


def test_database_connection():
    """Testet, ob die Datenbank erreichbar ist."""
    try:
        logging.info("Überprüfe die Verbindung zur Datenbank...")
        client.admin.command("ping")
        logging.info("✅ Verbindung zur Datenbank erfolgreich.")
        return True
    except Exception as e:
        logging.error(f"❌ Verbindung zur Datenbank fehlgeschlagen: {e}")
        return False


def test_api_endpoints():
    """Testet die Erreichbarkeit der API-Endpunkte."""
    base_url = "http://127.0.0.1:5000"

    # Beispiel-Daten
    test_register_data = {
        "username": "testuser",
        "password": "Test@1234",
        "email": "testuser@example.com"
    }
    test_login_data = {
        "username": "testuser",
        "password": "Test@1234"
    }

    endpoints = [
        {"url": "/api/questions", "method": "GET"},
        {"url": "/api/lexicon", "method": "GET"},
        {"url": "/api/register", "method": "POST", "data": test_register_data},
        {"url": "/api/login", "method": "POST", "data": test_login_data},
    ]

    success = True
    for endpoint in endpoints:
        try:
            logging.info(f"Teste API-Endpunkt: {base_url}{endpoint['url']}")
            if endpoint["method"] == "GET":
                response = requests.get(f"{base_url}{endpoint['url']}")
            elif endpoint["method"] == "POST":
                response = requests.post(f"{base_url}{endpoint['url']}", json=endpoint.get("data", {}))

            if response.status_code in [200, 201]:
                logging.info(f"✅ API {endpoint['url']} ist erreichbar. Status: {response.status_code}")
            else:
                logging.error(f"❌ API {endpoint['url']} nicht erreichbar. Status: {response.status_code}")
                success = False
        except Exception as e:
            logging.error(f"❌ Fehler beim Testen von {endpoint['url']}: {e}")
            success = False

    return success




if __name__ == "__main__":
    logging.info("Starte Start-Up Tests...")

    # Test: Datenbankverbindung
    db_ok = test_database_connection()

    # Test: API-Endpunkte
    logging.info("Warte, bis der Server startet (5 Sekunden)...")
    import time

    time.sleep(5)
    api_ok = test_api_endpoints()

    # Gesamtergebnis
    if db_ok and api_ok:
        logging.info("✅ Alle Tests erfolgreich. Die Anwendung ist bereit.")
    else:
        logging.error("❌ Ein oder mehrere Tests sind fehlgeschlagen.")

=======

Datei: lexicon_entry.py
Pfad: ..\models\lexicon_entry.py
Inhalt:
class LexiconEntry:
    def __init__(self, data):
        self.id = str(data.get('_id', ''))
        self.term = data.get('term', '')
        self.definition = data.get('definition', '')

    def to_dict(self):
        return {
            'id': self.id,
            'term': self.term,
            'definition': self.definition,
        }

=======

Datei: questions.py
Pfad: ..\models\questions.py
Inhalt:
class Question:
    def __init__(self, data):
        self.id = str(data.get('_id', ''))
        self.question = data.get('question', '')
        self.answer_options = data.get('answerOptions', [])
        self.correct_index = data.get('correctIndex', 0)
        self.references = data.get('references', [])

    def to_dict(self):
        return {
            'id': self.id,
            'question': self.question,
            'answerOptions': self.answer_options,
            'correctIndex': self.correct_index,
            'references': self.references,
        }

=======

Datei: user.py
Pfad: ..\models\user.py
Inhalt:
from werkzeug.security import generate_password_hash, check_password_hash

class User:
    def __init__(self, data):
        self.id = str(data.get('_id', ''))
        self.username = data.get('username', '')
        self.password_hash = data.get('password_hash', '')

    def set_password(self, password):
        self.password_hash = generate_password_hash(password)

    def check_password(self, password):
        return check_password_hash(self.password_hash, password)

    def to_dict(self):
        return {
            'id': self.id,
            'username': self.username,
        }

=======

Datei: __init__.py
Pfad: ..\models\__init__.py
Inhalt:

=======

Datei: auth.py
Pfad: ..\resources\auth.py
Inhalt:
from flask_restful import Resource, reqparse
from utils.database import db
from models.user import User
from flask_jwt_extended import create_access_token
import logging
from datetime import timedelta


from utils.validations import is_valid_email, is_valid_password  # Importiere die Validierungsfunktionen

class Register(Resource):
    def post(self):
        # Argumente parsen
        parser = reqparse.RequestParser()
        parser.add_argument('username', required=True, help='Username is required')
        parser.add_argument('password', required=True, help='Password is required')
        parser.add_argument('email', required=True, help='Email is required')
        args = parser.parse_args()

        username = args['username']
        password = args['password']
        email = args['email']

        # Validierung der E-Mail-Adresse
        if not is_valid_email(email):
            logging.warning(f"Ungültige E-Mail-Adresse: {email}")
            return {'message': 'Invalid email address'}, 400

        # Validierung des Passworts
        if not is_valid_password(password):
            logging.warning(f"Unsicheres Passwort für Benutzer: {username}")
            return {
                'message': 'Password must be at least 8 characters long, contain a number, and a special character'
            }, 400

        # Prüfen, ob der Benutzername bereits existiert
        if db.users.find_one({'username': username}):
            logging.warning(f"Benutzername existiert bereits: {username}")
            return {'message': 'Username already exists'}, 400

        # Benutzer erstellen und speichern
        user = User({'username': username, 'email': email})
        user.set_password(password)
        db.users.insert_one({
            'username': username,
            'email': email,
            'password_hash': user.password_hash
        })
        logging.info(f"Benutzer erfolgreich registriert: {username}")
        return {'message': 'User registered successfully'}, 201


class Login(Resource):
    def post(self):
        parser = reqparse.RequestParser()
        parser.add_argument('username', required=True, help='Username is required')
        parser.add_argument('password', required=True, help='Password is required')
        args = parser.parse_args()

        username = args['username']
        password = args['password']

        user_data = db.users.find_one({'username': username})
        if not user_data:
            logging.warning(f"Benutzer nicht gefunden: {username}")
            return {'message': 'Invalid username or password'}, 401

        user = User(user_data)
        if not user.check_password(password):
            logging.warning(f"Ungültiges Passwort für Benutzer: {username}")
            return {'message': 'Invalid username or password'}, 401

        access_token = create_access_token(identity=user.id, expires_delta=timedelta(hours=1))
        logging.info(f"Benutzer eingeloggt: {username}")
        return {'access_token': access_token}, 200

=======

Datei: lexicon.py
Pfad: ..\resources\lexicon.py
Inhalt:
from flask_restful import Resource
from utils.database import db
from models.lexicon_entry import LexiconEntry
import logging

class LexiconList(Resource):
    def get(self):
        try:
            lexicon_cursor = db.lexicon.find()
            lexicon = [LexiconEntry(l).to_dict() for l in lexicon_cursor]
            logging.info(f"Retrieved {len(lexicon)} lexicon entries")
            return lexicon, 200
        except Exception as e:
            logging.error(f"Error retrieving lexicon: {e}")
            return {'message': 'Error retrieving lexicon entries'}, 500

=======

Datei: questions.py
Pfad: ..\resources\questions.py
Inhalt:
from flask_restful import Resource
from utils.database import db
from models.questions import Question
import logging

class QuestionsList(Resource):
    def get(self):
        try:
            questions_cursor = db.questions.find()
            questions = [Question(q).to_dict() for q in questions_cursor]
            logging.info(f"Retrieved {len(questions)} questions")
            return questions, 200
        except Exception as e:
            logging.error(f"Error retrieving questions: {e}")
            return {'message': 'Error retrieving questions'}, 500

=======

Datei: __init__.py
Pfad: ..\resources\__init__.py
Inhalt:

=======

Datei: test_auth.py
Pfad: ..\tests\test_auth.py
Inhalt:
# tests/test_app.py

import unittest
from app import app

class TestApp(unittest.TestCase):
    def setUp(self):
        self.app = app.test_client()
    
    def test_home_page_not_found(self):
        response = self.app.get('/')
        self.assertEqual(response.status_code, 404)
    
    def test_invalid_endpoint(self):
        response = self.app.get('/invalid-endpoint')
        self.assertEqual(response.status_code, 404)

if __name__ == '__main__':
    unittest.main()

=======

Datei: test_lexicon.py
Pfad: ..\tests\test_lexicon.py
Inhalt:
# tests/test_generate_pdf.py

import unittest
from app import app
from unittest.mock import patch
from bson.objectid import ObjectId

class TestGeneratePDF(unittest.TestCase):
    def setUp(self):
        self.app = app.test_client()
    
    @patch('resources.generate_pdf.db')
    @patch('resources.generate_pdf.HTML')
    @patch('resources.generate_pdf.os')
    @patch('resources.generate_pdf.Environment')
    def test_generate_pdf_success(self, mock_env, mock_os, mock_html, mock_db):
        personalized_story_id = str(ObjectId())
        mock_db.personalized_stories.find_one.return_value = {
            '_id': ObjectId(personalized_story_id),
            'story_id': str(ObjectId()),
            'personal_data': {'child_name': 'Max'},
            'user_images': [],
            'created_at': None
        }
        mock_db.stories.find_one.return_value = {
            '_id': ObjectId(),
            'title': 'Geschichte 1',
            'scenes': []
        }
        mock_template = mock_env.return_value.get_template.return_value
        mock_template.render.return_value = '<html></html>'
        mock_html.return_value.write_pdf.return_value = True
        mock_os.path.join.return_value = '/path/to/pdf.pdf'
        
        response = self.app.get(f'/api/generate-pdf/{personalized_story_id}')
        self.assertEqual(response.status_code, 200)
        self.assertIn('pdf_path', response.get_json())
    
    def test_generate_pdf_invalid_id(self):
        response = self.app.get('/api/generate-pdf/invalid_id')
        self.assertEqual(response.status_code, 400)
        self.assertIn('Invalid personalized story ID', str(response.data))
    
    @patch('resources.generate_pdf.os')
    def test_download_pdf_success(self, mock_os):
        personalized_story_id = str(ObjectId())
        mock_os.path.exists.return_value = True
        response = self.app.get(f'/api/download-pdf/{personalized_story_id}')
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.headers['Content-Type'], 'application/pdf')
    
    @patch('resources.generate_pdf.os')
    def test_download_pdf_not_found(self, mock_os):
        personalized_story_id = str(ObjectId())
        mock_os.path.exists.return_value = False
        response = self.app.get(f'/api/download-pdf/{personalized_story_id}')
        self.assertEqual(response.status_code, 404)
        self.assertIn('PDF not found', str(response.data))

if __name__ == '__main__':
    unittest.main()

=======

Datei: test_questions.py
Pfad: ..\tests\test_questions.py
Inhalt:
# tests/test_personalize.py

import unittest
from app import app
from unittest.mock import patch
from bson.objectid import ObjectId

class TestPersonalize(unittest.TestCase):
    def setUp(self):
        self.app = app.test_client()
    
    @patch('resources.personalize.db')
    def test_personalize_story_success(self, mock_db):
        story_id = str(ObjectId())
        mock_db.stories.find_one.return_value = {'_id': ObjectId(story_id)}
        mock_db.personalized_stories.insert_one.return_value = type('obj', (object,), {'inserted_id': ObjectId()})
        
        data = {
            'story_id': story_id,
            'personal_data': {'child_name': 'Max'},
            'user_images': ['path/to/image1.jpg', 'path/to/image2.jpg']
        }
        response = self.app.post('/api/personalize', json=data)
        self.assertEqual(response.status_code, 201)
        self.assertIn('personalized_story_id', response.get_json())
    
    @patch('resources.personalize.db')
    def test_personalize_story_missing_name(self, mock_db):
        story_id = str(ObjectId())
        data = {
            'story_id': story_id,
            'personal_data': {},
            'user_images': []
        }
        response = self.app.post('/api/personalize', json=data)
        self.assertEqual(response.status_code, 400)
        self.assertIn("Child's name is required", str(response.data))
    
    @patch('resources.personalize.db')
    def test_personalize_story_invalid_story_id(self, mock_db):
        data = {
            'story_id': 'invalid_id',
            'personal_data': {'child_name': 'Max'},
            'user_images': []
        }
        response = self.app.post('/api/personalize', json=data)
        self.assertEqual(response.status_code, 400)
        self.assertIn('Invalid story ID', str(response.data))
    
    @patch('resources.personalize.db')
    def test_get_personalized_story_success(self, mock_db):
        personalized_story_id = str(ObjectId())
        mock_db.personalized_stories.find_one.return_value = {
            '_id': ObjectId(personalized_story_id),
            'story_id': str(ObjectId()),
            'personal_data': {'child_name': 'Max'},
            'user_images': [],
            'created_at': None
        }
        response = self.app.get(f'/api/personalized-story/{personalized_story_id}')
        self.assertEqual(response.status_code, 200)
        self.assertIn('Max', str(response.data))
    
    def test_get_personalized_story_invalid_id(self):
        response = self.app.get('/api/personalized-story/invalid_id')
        self.assertEqual(response.status_code, 400)
        self.assertIn('Invalid personalized story ID', str(response.data))

if __name__ == '__main__':
    unittest.main()

=======

Datei: __init__.py
Pfad: ..\tests\__init__.py
Inhalt:

=======

Datei: collect_py_files.py
Pfad: collect_py_files.py
Inhalt:
import os

def collect_py_files(root_dir, output_file="output_py_files.txt", exclude_dirs=None):
    """
    Sucht in root_dir (rekursiv) nach .py-Dateien und schreibt die Ergebnisse in output_file
    im folgenden Format:
    
    Datei: Dateiname
    Pfad: relativer/pfad/zum/Dateiname.kt
    Inhalt:
    <Inhalt der .py-Datei>
    
    =======
    
    :param root_dir: Das Wurzelverzeichnis, das durchsucht werden soll.
    :param output_file: Der Name der Ausgabedatei.
    :param exclude_dirs: Eine Liste von Ordnernamen, die nicht durchsucht werden sollen.
    """

    if exclude_dirs is None:
        exclude_dirs = []

    # Pfad für das Output-File
    script_dir = os.path.abspath(os.path.dirname(__file__))
    output_path = os.path.join(script_dir, output_file)

    # Für konsistente Ausgabe: erst leeren oder neu erstellen
    with open(output_path, "w", encoding="utf-8") as f_out:
        # Noch kein Inhalt schreiben, nur Datei leeren/anlegen.
        pass

    # Rekursiv durch root_dir laufen
    for folderpath, dirs, files in os.walk(root_dir):
        # Entferne Ordner, die in exclude_dirs enthalten sind
        dirs[:] = [d for d in dirs if d not in exclude_dirs]

        for file in files:
            if file.endswith(".py"):
                # Absoluter Pfad zum gefundenen File
                abs_path = os.path.join(folderpath, file)

                # Relativer Pfad (z. B. relativ zum Skript)
                rel_path = os.path.relpath(abs_path, script_dir)

                # Dateiinhalt lesen
                with open(abs_path, "r", encoding="utf-8") as f:
                    content = f.read()

                # In output_kt_files.txt anhängen
                with open(output_path, "a", encoding="utf-8") as f_out:
                    f_out.write(f"Datei: {file}\n")
                    f_out.write(f"Pfad: {rel_path}\n")
                    f_out.write("Inhalt:\n")
                    f_out.write(content)
                    f_out.write("\n=======\n\n")

    print(f"Fertig! Ergebnisse in: {output_path}")

if __name__ == "__main__":
    # Beispiel: Du definierst hier das Wurzelverzeichnis,
    # das durchsucht werden soll
    project_dir = r"D:\git\WAA_WaffenkundeBackend"  # Pfad anpassen
    
    # Liste von Ordnern, die nicht durchsucht werden sollen
    exclude_dirs = ["venv", "__pycache__", "source"]
    
    # Ruf die Funktion auf
    collect_py_files(root_dir=project_dir, output_file="output_py_files.txt", exclude_dirs=exclude_dirs)
=======

Datei: database.py
Pfad: ..\utils\database.py
Inhalt:
# utils/database.py

import logging  # Füge diesen Import hinzu
from pymongo import MongoClient
from config import Config

# MongoDB-Client erstellen
client = MongoClient(Config.MONGODB_URI)
db = client[Config.DATABASE_NAME]

# Verbindung überprüfen
try:
    client.admin.command('ping')
    logging.info("Connected to MongoDB successfully.")
except Exception as e:
    logging.error(f"Failed to connect to MongoDB: {e}")
    raise

=======

Datei: logging_config.py
Pfad: ..\utils\logging_config.py
Inhalt:
# utils/logging_config.py

import logging

def configure_logging(debug_mode):
    log_level = logging.DEBUG if debug_mode else logging.WARNING
    logging.basicConfig(
        level=log_level,
        format='%(asctime)s [%(levelname)s] %(message)s',
        handlers=[
            logging.StreamHandler()
        ]
    )

=======

Datei: validations.py
Pfad: ..\utils\validations.py
Inhalt:
# utils/validations.py

import re
from bson.objectid import ObjectId
from flask import current_app

def is_valid_name(name):
    return bool(name and name.strip())

def is_valid_object_id(oid):
    return ObjectId.is_valid(oid)

def allowed_file(filename):
    allowed_extensions = current_app.config['ALLOWED_EXTENSIONS']
    return '.' in filename and filename.rsplit('.', 1)[1].lower() in allowed_extensions

def is_valid_email(email):
    return re.match(r"[^@]+@[^@]+\.[^@]+", email)

def is_valid_password(password):
    # Passwort muss mindestens 8 Zeichen, eine Zahl und ein Sonderzeichen enthalten
    return len(password) >= 8 and any(char.isdigit() for char in password) and any(not char.isalnum() for char in password)

=======

Datei: __init__.py
Pfad: ..\utils\__init__.py
Inhalt:

=======

